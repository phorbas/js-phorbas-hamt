import {init_hamt_shared_codec} from '@phorbas/hamt'

import @{}
  init_opaque_shared_codec
  opaque_basic
  opaque_tahoe
  opaque_ecdsa
  opaque_ecdsa_tahoe

#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import {phorbas_store, bkc_with_js_map, u8_to_utf8} from '@phorbas/store'
import {cbor_encode, cbor_decode} from 'cbor-codec'
export {cbor_encode, cbor_decode} from 'cbor-codec'

export const { assert, expect } = require('chai')

init_opaque_shared_codec @:
  encode: cbor_encode
  decode: cbor_decode

init_hamt_shared_codec @:
  encode: cbor_encode
  decode: cbor_decode


function bind_phorbas_test_ctx(opaque) ::
  return () => phorbas_store(bkc_with_js_map(), {opaque})

export const all_phorbas_test_ctx = @{}
  opaque_basic: bind_phorbas_test_ctx(opaque_basic)
  opaque_tahoe: bind_phorbas_test_ctx(opaque_tahoe)
  opaque_ecdsa: bind_phorbas_test_ctx(opaque_ecdsa)
  opaque_ecdsa_tahoe: bind_phorbas_test_ctx(opaque_ecdsa_tahoe)

export const phorbas_test_ctx = all_phorbas_test_ctx.opaque_tahoe


export async function store_text_lines(text_lines, sync, stg) ::
  text_lines = Array.from(text_lines)

  const refs = [], u8_pairs = []
  const q = []
  for let idx=0; idx<text_lines.length; idx++ ::
    q.push @!>
      const ln = text_lines[idx]
      const k = await stg.opaque.from_content(ln)
      refs[idx] = k.k21pair()
      sync.add(k.k2loc)
      u8_pairs.push @# k.k2loc, await k.encode_utf8(ln)

  while q.length :: await q.pop()

  const u8_refs = cbor_encode(refs)
  const k_root = await stg.opaque.from_content(u8_refs)
  u8_pairs.push @# k_root.k2loc, await k_root.encode_content(u8_refs)
  sync.add(k_root.k2loc)

  if sync.done :: sync.done()

  await stg.bkc_store(u8_pairs)
  return k_root.k21pair()


export async function load_text_lines(root_ref, stg) ::
  let refs
  ::
    const k = await stg.opaque.from_k21pair(root_ref)

    const [[, ans]] = await stg.bkc_fetch([k.k2loc])
    if ! ans :: return

    refs = cbor_decode @ await k.decode_content(ans)

  const ref_map = new Map @
    refs.map @ ea => @#
      ea[0], stg.opaque.from_k21pair(ea)

  const ref_content = await
    stg.bkc_fetch @
      refs.map(ea => ea[0])

  return ref_content.map @\ [k2loc, u8_enc] ::>
    const k = await ref_map.get(k2loc)
    return await k.decode_utf8(u8_enc)

