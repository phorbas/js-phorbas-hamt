import {hamt_init_shared} from '@phorbas/hamt'

import @{} opaque_tahoe
#IF PLAT_WEB
  from '@phorbas/opaque/esm/web/index.mjs'
#ELIF PLAT_NODEJS
  from '@phorbas/opaque/esm/node/index.mjs'

import {bkc_with_js_map} from '@phorbas/store'
import {cbor_encode, cbor_decode} from 'cbor-codec'
export {cbor_encode, cbor_decode} from 'cbor-codec'

export const { assert, expect } = require('chai')

opaque_tahoe.init_shared_codec @:
  encode: cbor_encode
  decode: cbor_decode

hamt_init_shared @:
  encode: cbor_encode
  decode: cbor_decode


export async function phorbas_test_ctx() ::
  const stg = await bkc_with_js_map()
  stg.opaque = {__proto__: opaque_tahoe}
  return stg


export async function store_text(text, sync, stg) ::
  const k = await stg.opaque.from_content(text)
  await stg.bkc_store @#
    @[] k.k2loc, await k.encipher_utf8(text)

  sync.add(k.k2loc)

  if sync.done :: sync.done()

  return k.k21pair()


export async function load_text(root_ref, stg) ::
  const k = await stg.opaque.from_k21pair(root_ref)

  const [[, u8_enc]] = await stg.bkc_fetch([k.k2loc])
  if u8_enc ::
    return await k.decipher_utf8(u8_enc)



export async function store_text_lines(text_lines, sync, stg) ::
  text_lines = Array.from(text_lines)

  const refs = [], u8_pairs = []
  const q = []
  for let idx=0; idx<text_lines.length; idx++ ::
    q.push @!>
      const ln = text_lines[idx]
      const k = await stg.opaque.from_content(ln)
      refs[idx] = k.k21pair()
      sync.add(k.k2loc)
      u8_pairs.push @# k.k2loc, await k.encipher_utf8(ln)

  while q.length :: await q.pop()

  const u8_refs = cbor_encode(refs)
  const k_root = await stg.opaque.from_content(u8_refs)
  u8_pairs.push @# k_root.k2loc, await k_root.encipher(u8_refs)
  sync.add(k_root.k2loc)

  if sync.done :: sync.done()

  await stg.bkc_store(u8_pairs)
  return k_root.k21pair()


export async function load_text_lines(root_ref, stg) ::
  let refs
  ::
    const k = await stg.opaque.from_k21pair(root_ref)

    const [[, ans]] = await stg.bkc_fetch([k.k2loc])
    if ! ans :: return

    refs = cbor_decode @ await k.decipher(ans)

  const ref_map = new Map @
    refs.map @ ea => @#
      ea[0], stg.opaque.from_k21pair(ea)

  const ref_content = await
    stg.bkc_fetch @
      refs.map(ea => ea[0])

  return ref_content.map @\ [k2loc, u8_enc] ::>
    const k = await ref_map.get(k2loc)
    return await k.decipher_utf8(u8_enc)

